//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.18444
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;

//TODO: doesn't hit player, when he's at max. height
public class FallDownAttackBehaviour : IBehaviour
{
	private EnemyBehaviour generalBehaviour;

	private bool fallDownInProgress;

	private static Vector3 correctionVector = Vector3.zero;

	/// <summary>
	/// Initializes a new instance of the <see cref="FallDownAttackBehaviour"/> class.
	/// Bahaviour change is locked until Attack finished.
	/// </summary>
	public FallDownAttackBehaviour (EnemyBehaviour generalBehaviour)
	{
		this.generalBehaviour = generalBehaviour;
		fallDownInProgress = false;
		generalBehaviour.behaviourChangeLocked = true;
	}

	public void execute(float timePassed)
	{
		if (fallDownInProgress)
		{
			if (isFallDownAttackFinished())
			{
                generalBehaviour.enemy.rigidbody.useGravity = false;
                generalBehaviour.enemy.rigidbody.velocity = Vector3.zero;
				generalBehaviour.agent.baseOffset = EnemyBehaviour.defaultNavMeshBaseOffset;
				generalBehaviour.agent.enabled = true;
				generalBehaviour.isClimbingOnCeiling = false;
				fallDownInProgress = false;
				generalBehaviour.behaviourChangeLocked = false;
			}
		}
		else
		{
			executeFallDownAttack();
		}
	}

	/// <summary>
	/// Is the player reachable with a FallDownAttack.
	/// </summary>
	/// <returns><c>true</c>, if player reachable, <c>false</c> otherwise.</returns>
	/// <param name="deltaHeight">playerPos.y - enemyPos.y</param>
	/// <param name="deltaDistance">Distance between player and enemy on xz-plane</param>
	public static bool isPlayerReachable(float deltaHeight, float deltaDistance)
	{
		if (deltaHeight < 0.0f)
			deltaHeight *= -1.0f;
		//Debug.Log (deltaHeight + ", " + deltaDistance);
		if (deltaHeight < 1.0f)
		{
			if (deltaDistance < 1.5f)
				return true;
			return false;
		}
		else if (deltaHeight < 2.0f)
		{
			if (deltaDistance < 2.5f)
				return true;
			return false;
		}
		else if (deltaHeight < 3.0f)
		{
			if (deltaDistance < 3.5f)
				return true;
			return false;
		}
		else if (deltaHeight < 4.0f)
		{
			if (deltaDistance < 4.5f)
				return true;
			return false;
		}
		else if (deltaDistance < 5.5f)
			return true;
		return false;
	}

	private void executeFallDownAttack()
	{
		Vector3 enemyPosition = generalBehaviour.enemy.transform.position;
		Vector3 playerPosition = generalBehaviour.player.transform.position;

		Vector3 positionDelta = playerPosition - enemyPosition;
		positionDelta.y = 0.0f;

		Vector3 targetVector = calculateFallDownVector(positionDelta);

		generalBehaviour.agent.enabled = false;
		generalBehaviour.enemy.rigidbody.useGravity = true;
		generalBehaviour.enemy.rigidbody.AddForce(targetVector, ForceMode.Impulse);

        generalBehaviour.collisionWithObject = false;
		fallDownInProgress = true;
	}

	private Vector3 calculateFallDownVector(Vector3 positionDelta)
	{
		return positionDelta + correctionVector;
	}

	private bool isFallDownAttackFinished()
	{
		if (generalBehaviour.enemy.transform.position.y < 2.0f)
		{
			return true;
		}
        else if (generalBehaviour.collisionWithObject)
        {
            return true;
        }
		return false;
	}
}


